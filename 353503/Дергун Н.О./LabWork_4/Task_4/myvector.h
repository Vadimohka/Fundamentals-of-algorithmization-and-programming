#ifndef VECTOR_H
#define VECTOR_H


#include <stdexcept>

#include "utilityfunctions.h"


namespace My {

using ull = unsigned long long;


// allocator'c implementation

template<typename T>
class Allocator {
public:

    T* allocate(const ull cnt) {
        return reinterpret_cast<T*>(::operator new(cnt * sizeof(T)));
    }

    void deallocate(void* ptr, const ull) noexcept {
        ::operator delete(ptr);
    }

    template<typename ... Args>
    void construct(T* ptr, Args&& ... args) {
        new(ptr) T(forward<Args>(args) ...);
    }

    void destroy(const T* ptr) noexcept(noexcept(T().~T())) {
        ptr->~T();
    }
};


// vector's implementation

template<typename T, typename Alloc = Allocator<T>>
class Vector {
    T* _array;
    ull _size;
    ull _capacity;
    Alloc _alloc;

public:
    // iterators
    class iterator;
    class const_iterator;
    class reverse_iterator;


    // the rule of five (can be generated by compiler)
    explicit Vector(const Vector<T, Alloc>& v) :
        _alloc(Alloc()), _size(0), _capacity(0), _array(nullptr) {
        reserve(v._capacity);
        ull i = 0;
        try {
            for (; i < v._size; ++i) {
                _alloc.construct(_array + i, v[i]);
            }
        } catch (...) {
            for (ull j = 0; j < i; ++j) {
                _alloc.destroy(_array + j);
            }
            throw;
        }
        _size = v._size;
    }

    explicit Vector(Vector<T, Alloc>&& v) noexcept :
        _alloc(Alloc()), _size(v._size), _capacity(v._capacity), _array(v._array) {
        v._array = nullptr;
        v._capacity = 0;
        v._size = 0;
        v.reserve(1);
    }

    Vector& operator=(const Vector<T, Alloc>& v) {
        if (&v != this) {
            clear();
            reserve(v._capacity);
            ull i = 0;
            try {
                for (; i < v.size(); ++i) {
                    _alloc.construct(_array + i, v[i]);
                }
            } catch (...) {
                for (ull j = 0; j < i; ++j) {
                    _alloc.destroy(_array + j);
                }
                throw;
            }
        }
        return *this;
    }

    Vector& operator=(Vector<T, Alloc>&& v) noexcept {
        for (int i = 0; i < _size; ++i) {
            _alloc.destroy(_array + i);
        }
        _alloc.deallocate(_array, _capacity);
        _array = nullptr;

        _size = v._size;
        _capacity = v._capacity;
        _array = v._array;
        v._array = nullptr;
        v._capacity = 0;
        v._size = 0;
        return *this;
    }

    ~Vector() noexcept {
        resize(0);
        if (_array != nullptr) {
            _alloc.deallocate(_array, _capacity);
        }
    }


    // other constructors
    Vector()  : _size(0), _capacity(0), _alloc(Alloc()), _array(nullptr) {
        reserve(1);
    };

    template<typename U>
    explicit Vector(const ull size = 1, U&& value = T(), const Alloc alloc = Alloc()):
        _size(0), _capacity(0), _alloc(alloc), _array(nullptr) {
        resize(size, forward<U>(value));
    }

    template<typename A>
    explicit Vector(const Vector<T, A>& v) :
        _alloc(Alloc()), _size(0), _capacity(0), _array(nullptr) {
        reserve(v._capacity);
        ull i = 0;
        try {
            for (; i < v._size; ++i) {
                _alloc.construct(_array + i, v[i]);
            }
        } catch (...) {
            for (ull j = 0; j < i; ++j) {
                _alloc.destroy(_array + j);
            }
            throw;
        }
        _size = v._size;
    }

    template<typename A>
    explicit Vector(Vector<T, A>&& v) noexcept :
        _alloc(Alloc()), _size(v._size), _capacity(v._capacity), _array(v._array) {
        v._array = nullptr;
        v._capacity = 0;
        v._size = 0;
        v.reserve(1);
    }


    // low size/capacity changing
    void resize(const ull newSize) {
        if (newSize < _size) {
            for (ull i = newSize; i < _size; ++i) {
                _alloc.destroy(_array + i);
            }
        } else if (newSize > _size) {
            if (newSize > _capacity) {
                reserve(newSize);
            }
            ull i = _size;
            try {
                for (; i < newSize; ++i) {
                    _alloc.construct(_array + i, T()); // rvalue
                }
            } catch (...) {
                for (ull j = _size; j < i; ++j) {
                    _alloc.destroy(_array + j);
                }
                throw;
            }
        }

        _size = newSize;
    }

    template<typename TT>
    void resize(const ull newSize, TT&& deffaultValue) {
        if (newSize < _size) {
            for (ull i = newSize; i < _size; ++i) {
                _alloc.destroy(_array + i);
            }
        } else if (newSize > _size) {
            if (newSize > _capacity) {
                reserve(newSize);
            }
            ull i = _size;
            try {
                for (; i < newSize; ++i) {
                    _alloc.construct(_array + i, deffaultValue); // lvalue
                }
            } catch (...) {
                for (ull j = _size; j < i; ++j) {
                    _alloc.destroy(_array + j);
                }
                throw;
            }
        }

        _size = newSize;
    }

    void reserve(const ull newCapacity) {
        if (newCapacity <= _capacity) { return; }

        T* newArray = _alloc.allocate(newCapacity);
        ull i = 0;
        try {
            for (; i < _size; ++i) {
                _alloc.construct(newArray + i, std::move_if_noexcept(_array[i]));
            }
        } catch (...) {
            for (ull j = 0; j < i; ++j) {
                _alloc.destroy(newArray + j);
            }
            _alloc.deallocate(newArray, newCapacity);
            newArray = nullptr;
            throw;
        }
        for (i = 0; i < _size; ++i) {
            _alloc.destroy(_array + i);
        }
        if (_array != nullptr) {
            _alloc.deallocate(_array, _capacity);
            _array = nullptr;
        }
        _array = newArray;
        _capacity = newCapacity;
    }


    // adding new elements
    template<typename... Args>
    iterator emplace_back(Args&& ... args) {
        if (_size == _capacity) { reserve(_capacity * 2); }
        _alloc.construct(_array + _size, forward<Args>(args)...);
        ++_size;
        return end() - 1;
    }

    template<typename... Args>
    iterator emplace(const iterator pos, const Args ... args) {
        if (pos < begin() || pos > end()) { throw std::out_of_range("Wrong iterator."); }

        if (pos == end()) {
            return emplace_back(args ...);
        }
        T temp(args...);

        ull index = pos - begin();
        resize(_size + 1);

        for (auto i = end(); i > begin() + index; --i) {
            *i = move(*(i - 1));
        }
        *(begin() + index) = move(*temp);
        return begin() + index;
    }

    template<typename U>
    void push_back(U&& value) {
        emplace_back(forward<U>(value));
    }

    template<typename U>
    iterator insert(const iterator pos, U&& value) {
        ull index = pos - begin();
        return emplace(pos, forward<U>(value));
    }

    iterator insert(const iterator pos, const T* array, const ull amnt) {
        if (pos < begin() || pos > end()) { throw std::out_of_range("Wrong iterator."); }

        ull index = pos - begin();

        if (pos == end()) {

            ull i = 0;
            try {
                for (i = 0; i < amnt; ++i) {
                    push_back(array[i]);
                }
            } catch (...) {
                for (ull j = 0; j < i; ++j) {
                    pop_back();
                }
                throw;
            }

            return begin() + index;
        }

        resize(_size + amnt);
        for (auto i = end(); i >= begin() + index + amnt; --i) {
            *i = *(i - amnt);
        }
        for (ull i = 0; i < amnt; ++i) {
            *(begin() + index + i) = array[i];
        }

        return begin() + index;
    }


    // deleting elements
    void pop_back() noexcept {
        if (empty()) { return; }
        _alloc.destroy(_array + _size - 1);
        --_size;
    }

    iterator erase(const iterator pos) {
        if (pos < begin() || pos >= end()) { throw std::out_of_range("Wrong iterator."); }

        ull index = pos - begin();
        for (ull i = index; i < _size - 1; ++i) {
            *(_array + i) = std::move_if_noexcept(*(_array + i + 1));
        }

        resize(_size - 1);
        return end();
    }

    iterator erase(iterator start, iterator end) {
        if (start > end) { My::swap(start, end); }
        if (start < begin() || end > end()) { throw std::out_of_range("Wrong range."); }

        while (end != this->end()) {
            *start = move(*end);
            ++start;
            ++end;
        }

        resize(_size - (end - start));
        return end();
    }


    // access to elements
    T& at(const ull pos) {
        if (pos >= _size) {
            throw std::out_of_range("Impossible index.");
        }
        return _array[pos];
    }

    T& operator[](const ull pos) {
        return _array[pos];
    }

    const T& operator[](const ull pos) const {
        return _array[pos];
    }

    T& back() {
        return _array[_size - 1]; // Calling back on an empty container causes undefined behavior.
    }

    T& front() {
        return *_array; // Calling front on an empty container causes undefined behavior.
    }

    T* data() {
        return _array;
    }


    // iterators methods
    iterator begin() {
        return iterator(_array);
    }

    iterator end() {
        return iterator(_array + _size);
    }

    const_iterator begin() const {
        return const_iterator(_array);
    }

    const_iterator end() const {
        return const_iterator(_array + _size);
    }

    const_iterator cbegin() const {
        return const_iterator(_array);
    }

    const_iterator cend() const {
        return const_iterator(_array + _size);
    }

    reverse_iterator rbegin() {
        return reverse_iterator(_array + _size - 1);
    }

    reverse_iterator rend() {
        return reverse_iterator(_array - 1);
    }


    // info methods
    ull capacity() const {
        return _capacity;
    }

    ull size() const {
        return _size;
    }

    bool empty() const {
        return _size == 0;
    }

    ull max_size() const {
        return (LONG_LONG_MAX * 2 - 1) / sizeof(T);
    }


    // edit methods
    template<typename U>
    void assign(const ull count, U&& value) {
        resize(0);
        resize(count, forward<U>(value));
    }

    void clear() {
        resize(0);
    }

    template<typename A>
    void swap(Vector<T, A>& other) {
        Vector temp = other;
        other = *this;
        *this = temp;
    }
};


// iterators' implementation
template<typename T, typename Alloc>
class Vector<T, Alloc>::iterator {
protected:
    T* _ptr;

public:
    explicit iterator(T* pointer) : _ptr(pointer) {};

    T& operator*() { return *_ptr; }

    template<typename U>
    explicit iterator(U&& iterator) : _ptr(iterator.ptr) {}

    template<typename U>
    iterator& operator=(U&& other) {
        if (this != &other) {
            _ptr = other.ptr;
        }
        return *this;
    }

    virtual ~iterator() = default;

    virtual iterator& operator+=(int d) {
        _ptr += d;
        return *this;
    }

    virtual iterator& operator-=(int d) {
        _ptr -= d;
        return *this;
    }

    T* operator->() { return _ptr; }
    const T* operator->() const { return _ptr; }

    bool operator==(const iterator& other) { return _ptr == other._ptr; }
    bool operator!=(const iterator& other) { return _ptr != other._ptr; }
    virtual bool operator<(const iterator& other) const { return _ptr < other._ptr; }
    virtual bool operator>(const iterator& other) const { return _ptr > other._ptr; }
    virtual bool operator<=(const iterator& other) const { return _ptr <= other._ptr; }
    virtual bool operator>=(const iterator& other) const { return _ptr >= other._ptr; }

    virtual iterator operator++() { return iterator(++_ptr); }
    virtual iterator operator--() { return iterator(--_ptr); }
    virtual const iterator operator++(int) { return iterator(_ptr++); }
    virtual const iterator operator--(int) { return iterator(_ptr--); }

    virtual iterator operator+(int d) { return iterator(_ptr + d); }
    virtual iterator operator-(int d) { return iterator(_ptr - d); }
    virtual int operator-(const iterator& other) { return _ptr - other._ptr; }
};

template<typename T, typename Alloc>
class Vector<T, Alloc>::const_iterator : public Vector<T, Alloc>::iterator {
public:
    explicit const_iterator(T* pointer) : Vector<T, Alloc>::iterator(pointer) {};

    const T& operator*() { return *(this->_ptr); }

    template<typename U>
    explicit const_iterator(U&& const_iterator) : iterator(const_iterator) {}
};

template<typename T, typename Alloc>
class Vector<T, Alloc>::reverse_iterator : public Vector<T, Alloc>::iterator {
public:
    explicit reverse_iterator(T* pointer) : Vector<T, Alloc>::iterator(pointer) {};

    T& operator*() { return *(this->_ptr); }

    template<typename U>
    explicit reverse_iterator(U&& reverse_iterator) : iterator(reverse_iterator) {}

    bool operator<(const iterator& other) const override { return this->_ptr > other._ptr; }
    bool operator>(const iterator& other) const override { return this->_ptr < other._ptr; }
    bool operator<=(const iterator& other) const override { return this->_ptr >= other._ptr; }
    bool operator>=(const iterator& other) const override { return this->_ptr <= other._ptr; }

    iterator operator++() override { return iterator(--this->_ptr); }
    iterator operator--() override { return iterator(++this->_ptr); }
    const iterator operator++(int) override { return iterator(this->_ptr--); }
    const iterator operator--(int) override { return iterator(this->_ptr++); }

    iterator operator+(int d) override { return iterator(this->_ptr - d); }
    iterator operator-(int d) override { return iterator(this->_ptr + d); }
    int operator-(const iterator& other) override { return other._ptr - this->_ptr; }
};

} // namespace My

#endif // VECTOR_H
